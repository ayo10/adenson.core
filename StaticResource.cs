using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using System.Reflection;

namespace Adenson
{
	/// <summary>
	/// Utility class to get alternate values that can be changed using first .snuiresource files 
	/// or a fixed resx file named 'SR' generated by ResXFileCodeGenerator. This allows set strings
	/// in assemblies to be changeable without having to recompile code.<Br/>
	/// This class is an exact replica from Adenson.Web.UI
	/// </summary>
	/// <remarks>
	/// For SR resx files if detected, StaticResource.GetValue will attempt to look for the specified key first,
	/// then the string.Concat(type.Name, key) next, then string.Concat(type.FullName, key)
	/// </remarks>
	public class StaticResource
	{
		#region Variables
		private static Dictionary<string, Dictionary<string, ResourceData>> typesResourcesTable;
		private Type _type;
		private System.Resources.ResourceManager resourceManager;
		private string srtypeResourcePreKey;
		#endregion
		#region Constructors

		static StaticResource()
		{
			typesResourcesTable = new Dictionary<string, Dictionary<string, ResourceData>>();
			string bindir = Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().CodeBase).Replace("file:\\", String.Empty);
			foreach (string file in Directory.GetFiles(bindir, "*.snuiresource"))
			{
				XmlDocument doc = new XmlDocument();
				try
				{
					doc.Load(file);
				}
				catch (System.Xml.XmlException ex)
				{
					throw new InvalidOperationException("The file " + file + " is inproperly formatted", ex);
				}

				foreach (XmlNode node in doc.SelectNodes("//type"))
				{
					Dictionary<string, ResourceData> table = new Dictionary<string, ResourceData>();
					object globalPreserve = null;
					if (node.Attributes["preserve"] != null)
					{
						globalPreserve = Convert.ToBoolean(node.Attributes["preserve"].Value);
					}
					foreach (XmlNode subnode in node.SelectNodes("data"))
					{
						ResourceData data = new ResourceData();
						data.Name = subnode.Attributes["name"].Value;
						data.Type = subnode.Attributes["type"] == null ? "System.String" : subnode.Attributes["type"].Value;
						data.MimeType = subnode.Attributes["mimetype"] == null ? null : subnode.Attributes["mimetype"].Value;
						if (globalPreserve == null) data.Preserve = subnode.Attributes["preserve"] == null ? true : Convert.ToBoolean(subnode.Attributes["preserve"].Value);
						else data.Preserve = (bool)globalPreserve;

						switch (data.Type)
						{
							case "string":
							case "System.String": 
								string value = subnode.SelectSingleNode("value").InnerText;
								if (data.Preserve) data.Value = value;
								else data.Value = value.Trim('\r', '\n', '\t');
								break;
							case "string[]":
							case "System.String[]": 
								XmlNodeList list = subnode.SelectNodes("value");
								string[] values = new string[list.Count];
								for (int i=0; i<values.Length; i++)
								{
									string str = list[i].InnerText;
									if (data.Preserve) values[i] = str;
									else values[i] = str.Trim('\r', '\n', '\t');
								}
								data.Value = values;
								break;
							case "bool": 
							case "System.Boolean":
								data.Value = Convert.ToBoolean(subnode.SelectSingleNode("value").InnerText.Trim('\n', '\r', '\t', ' '));
								break;
							case "char": 
							case "System.Char":
								data.Value = Convert.ToChar(subnode.SelectSingleNode("value").InnerText.Trim('\n', '\r', '\t', ' '));
							break;
							case "System.DateTime": 
								data.Value = Convert.ToDateTime(subnode.SelectSingleNode("value").InnerText.Trim('\n', '\r', '\t', ' '));
								break;
							case "decimal": 
							case "System.Decimal":
								data.Value = Convert.ToDecimal(subnode.SelectSingleNode("value").InnerText.Trim('\n', '\r', '\t', ' '));
								break;
							case "double": 
							case "System.Double":
								data.Value = Convert.ToDouble(subnode.SelectSingleNode("value").InnerText.Trim('\n', '\r', '\t', ' '));
								break;
							case "short": 
							case "System.Int16":
								data.Value = Convert.ToInt16(subnode.SelectSingleNode("value").InnerText.Trim('\n', '\r', '\t', ' ')); 
								break;
							case "int": 
							case "System.Int32":
								data.Value = Convert.ToInt32(subnode.SelectSingleNode("value").InnerText.Trim('\n', '\r', '\t', ' ')); 
								break;
							case "long": 
							case "System.Int64":
								data.Value = Convert.ToInt64(subnode.SelectSingleNode("value").InnerText.Trim('\n', '\r', '\t', ' ')); 
								break;
							case "float": 
							case "System.Single":
								data.Value = Convert.ToSingle(subnode.SelectSingleNode("value").InnerText.Trim('\n', '\r', '\t', ' ')); 
								break;
						}
						table.Add(data.Name, data);
					}
					typesResourcesTable.Add(node.Attributes["name"].Value, table);
				}
			}
		}
		/// <summary>
		/// Initializes a new resource manager class using the type specified.
		/// </summary>
		public StaticResource(Type type)
		{
			if (type == null) throw new ArgumentNullException("type");
			this.Type = type;

			if (type.Assembly == this.GetType().Assembly) resourceManager = SR.ResourceManager;
			else
			{
				string assembly = type.Assembly.FullName.Split(',')[0].Trim();
				//typeName;
				//WebUtil.GetAssemblyAndTypeName(type, out assembly, out typeName);
				Type srType = type.Assembly.GetType(string.Concat(assembly, ".SR"), false, false);
				if (srType != null)
				{
					PropertyInfo propertyInfo = srType.GetProperty("ResourceManager", BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Instance);
					if (propertyInfo != null) resourceManager = (System.Resources.ResourceManager)propertyInfo.GetValue(type, null);
				}
			}
			if (resourceManager != null) srtypeResourcePreKey = type.FullName.Replace(".", String.Empty);
		}

		#endregion
		#region Properties

		public Type Type
		{
			get { return _type; }
			private set { _type = value; }
		}

		#endregion
		#region Methods

		/// <summary>
		/// Gets the boolean result of the key from the resource file from the type's full name hierachy
		/// </summary>
		/// <param name="key">The key to use to find value</param>
		/// <returns>The value if found, false otherwise</returns>
		public virtual bool GetBoolean(string key)
		{
			return Convert.ToBoolean(this.GetValue(key));
		}
		/// <summary>
		/// Gets the integer result of the key from the resource file from the type's full name hierachy
		/// </summary>
		/// <param name="key">The key to use to find value</param>
		/// <returns>The value if found, 0 otherwise</returns>
		public virtual short GetInt16(string key)
		{
			return Convert.ToInt16(this.GetValue(key));
		}
		/// <summary>
		/// Gets the integer result of the key from the resource file from the type's full name hierachy
		/// </summary>
		/// <param name="key">The key to use to find value</param>
		/// <returns>The value if found, 0 otherwise</returns>
		public virtual int GetInt32(string key)
		{
			return Convert.ToInt32(this.GetValue(key));
		}
		/// <summary>
		/// Gets the integer result of the key from the resource file from the type's full name hierachy
		/// </summary>
		/// <param name="key">The key to use to find value</param>
		/// <returns>The value if found, 0 otherwise</returns>
		public virtual long GetInt64(string key)
		{
			return Convert.ToInt64(this.GetValue(key));
		}
		/// <summary>
		/// Calls string.Format(GetString(type, key), formatArguments). If a <see cref="System.FormatException"/> is thrown,
		/// it then calls GetString(type, key) 
		/// </summary>
		/// <param name="key">The key to use to find value</param>
		/// <param name="arguments">The format arguments to pass to string.Format</param>
		/// <returns>A copy of format in which the format items have been replaced by the System.String equivalent of the corresponding instances of System.Object in args.</returns>
		public virtual string GetString(string key, params object[] arguments)
		{
			string result = (string)this.GetValue(key);
			if (arguments == null || arguments.Length == 0) return result;
			return string.Format(result, arguments);
		}
		/// <summary>
		/// Gets the value with the specified key
		/// </summary>
		/// <param name="key">The key</param>
		/// <returns>The value</returns>
		public virtual object GetValue(string key)
		{
			if (String.IsNullOrEmpty(key)) throw new ArgumentNullException("key", ExceptionMessages.ArgumentNullOrEmpty);

			Dictionary<string, ResourceData> dictionary = null;
			typesResourcesTable.TryGetValue(this.Type.FullName, out dictionary);

			object result = null;
			if (dictionary != null)
			{
				ResourceData data = null;
				dictionary.TryGetValue(key, out data);
				if (data == null) result = null;
				else result = data.Value;
			}

			if (result == null && resourceManager != null)
			{
				result = resourceManager.GetObject(key);
				if (result == null) result = resourceManager.GetObject(string.Concat(this.Type.Name, key));
				if (result == null) result = resourceManager.GetObject(string.Concat(srtypeResourcePreKey, key));
			}
			return result;
		}
		/// <summary>
		/// Gets the value with the specified key
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="key">The key</param>
		/// <returns>The value</returns>
		public virtual T GetValue<T>(string key)
		{
			return (T)Convert.ChangeType(this.GetValue(key), typeof(T));
		}

		#endregion
		#region Static Methods

		/// <summary>
		/// Gets the boolean result of the key from the resource file from the type's full name hierachy
		/// </summary>
		/// <param name="type">The type from which a fullname will be derived, then, used as a Type key</param>
		/// <param name="key">The key to use to find value</param>
		/// <returns>The value if found, false otherwise</returns>
		public static bool GetBoolean(Type type, string key)
		{
			return new StaticResource(type).GetBoolean(key);
		}
		/// <summary>
		/// Gets the integer result of the key from the resource file from the type's full name hierachy
		/// </summary>
		/// <param name="type">The type from which a fullname will be derived, then, used as a Type key</param>
		/// <param name="key">The key to use to find value</param>
		/// <returns>The value if found, 0 otherwise</returns>
		public static Int16 GetInt16(Type type, string key)
		{
			return new StaticResource(type).GetInt16(key);
		}
		/// <summary>
		/// Gets the integer result of the key from the resource file from the type's full name hierachy
		/// </summary>
		/// <param name="type">The type from which a fullname will be derived, then, used as a Type key</param>
		/// <param name="key">The key to use to find value</param>
		/// <returns>The value if found, 0 otherwise</returns>
		public static int GetInt32(Type type, string key)
		{
			return new StaticResource(type).GetInt32(key);
		}
		/// <summary>
		/// Gets the integer result of the key from the resource file from the type's full name hierachy
		/// </summary>
		/// <param name="type">The type from which a fullname will be derived, then, used as a Type key</param>
		/// <param name="key">The key to use to find value</param>
		/// <returns>The value if found, 0 otherwise</returns>
		public static Int64 GetInt64(Type type, string key)
		{
			return new StaticResource(type).GetInt64(key);
		}
		/// <summary>
		/// Gets the string result of the key from the resource file from the type's full name hierachy
		/// </summary>
		/// <param name="type">The type from which a fullname will be derived, then, used as a Type key</param>
		/// <param name="key">The key to use to find value</param>
		/// <returns>The value if found, null otherwise</returns>
		public static string GetString(Type type, string key, params object[] arguments)
		{
			return new StaticResource(type).GetString(key);
		}
		/// <summary>
		/// Gets the value with the specified key
		/// </summary>
		/// <param name="type"></param>
		/// <param name="key">The key</param>
		/// <returns>The value</returns>
		public static object GetValue(Type type, string key)
		{
			return new StaticResource(type).GetValue(key);
		}
		/// <summary>
		/// Gets the value with the specified key
		/// </summary>
		/// <param name="type"></param>
		/// <param name="key">The key</param>
		/// <returns>The value</returns>
		public static T GetValue<T>(Type type, string key)
		{
			return new StaticResource(type).GetValue<T>(key);
		}

		#endregion
	}
	#region ResourceData Class
	internal class ResourceData
	{
		public bool Preserve = true;
		public string Name;
		public string Type = "System.String";
		public string MimeType;
		public object Value;
	}
	#endregion
}